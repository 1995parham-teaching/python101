\documentclass{../py-lecture}

\subtitle{Packages}

\begin{document}

\begin{frame}
  \titlepage{}
\end{frame}
\begin{frame}
  \frametitle{Outline}
  \tableofcontents{}
\end{frame}

\section{Input/Output}

\begin{frame}[fragile]
	\frametitle{Keyboard Input}
    \begin{itemize}
      \item The input() function reads a line from sys.stdin and
        returns it with the trailing newline stripped.
    \end{itemize}
    \begin{minted}[bgcolor=Black]{python}
name = input("Enter your input: ")
print("Received input is : ", name)
    \end{minted}
\end{frame}

\begin{frame}
	\frametitle{File IO}
  \begin{itemize}
    \item The open Function
    \item The file Object
    \item The \mintinline{python}|close()| Method
    \item The \mintinline{python}|write()| Method
    \item The \mintinline{python}|read()| Method
    \item Check
    \href{https://docs.python.org/3/library/functions.html}{here}
    for more details and functions.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The open Function}
  \begin{itemize}
    \item Before you can read or write a file,
    you have to open it using Python's built-in open() function.
    \item This function creates a file object, which would be utilized
    to call other support methods associated with it.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
file_object = open(file_name [, access_mode])
	\end{minted}
  \begin{minted}[bgcolor=Black]{python}
fo = open("foo.txt", "w", encoding='utf-8')
	\end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The write() Method}
  \begin{itemize}
    \item The write() method writes any string to an open file.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
file_object.write(string)
  \end{minted}
  \begin{minted}[bgcolor=Black]{python}
# Open a file
fo = open("foo.txt", "wb")
fo.write( "Python is a great language.\nYeah its great!!\n")

# Close opend file
fo.close()
  \end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The read() Method}
  \begin{itemize}
    \item The read() method reads a string from an open file.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
file_object.read([count])
  \end{minted}
  \begin{minted}[bgcolor=Black]{python}
# Open a file
fo = open("foo.txt", "r+", encoding="utf-8")
str = fo.read(10);
print("Read String is : ", str)
# Close opend file
fo.close()
	\end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The readline() Method}
  \begin{itemize}
    \item Read one entire line from the file.
    \item A trailing newline character is kept in the string.
    \item If the size argument is present and non-negative,
    it is a maximum byte count (including the trailing newline)
    and an incomplete line may be returned.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
file_object.readline([size])
  \end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The readlines() Method}
  \begin{itemize}
    \item Read until EOF using readline() and return a
      list containing the lines thus read.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
file_object.readlines([sizehint])
  \end{minted}
\end{frame}

\section{Iterators \& Generators}

\begin{frame}[fragile]
	\frametitle{Iterators}
  \begin{itemize}
    \item There are many types of objects which can be used with a for loop.
    These are called \textcolor{Orange}{iterable} objects.
    \item The built-in function \textcolor{Orange}{iter} takes an \textcolor{Orange}{iterable}
    object and returns an iterator.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
>>> x = iter([1, 2, 3])
>>> x
<list_iterator object at 0x7fbe1813caf0>
>>> next(x)
1
>>> next(x)
2
>>> next(x)
3
  \end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Iterators}
  \begin{itemize}
    \item Iterators are implemented as classes.
  \end{itemize}
  \begin{minted}[fontsize=\scriptsize,bgcolor=Black]{python}
class yrange:
  def __init__(self, n):
    self.i = 0
    self.n = n

  def __iter__(self):
    return self

  def __next__(self):
      if self.i < self.n:
          i = self.i
          self.i += 1
          return i
      else:
          raise StopIteration()
    \end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Iterators}
  \begin{itemize}
    \item In the above case, both the iterable and iterator are the same object. Notice that the \mintinline{python}|__iter__| method returned \mintinline{python}|self|.
  \end{itemize}
  \begin{minted}[bgcolor=Black]{python}
class zrange:
    def __init__(self, n):
        self.n = n

    def __iter__(self):
        return zrange_iter(self.n)
  \end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Iterators}
  \begin{minted}[fontsize=\scriptsize,bgcolor=Black]{python}
class zrange_iter:
    def __init__(self, n):
        self.i = 0
        self.n = n

    def __iter__(self):
        # Iterators are iterables too.
        # Adding this functions to make them so.
        return self

    def __next__(self):
        if self.i < self.n:
            i = self.i
            self.i += 1
            return i
        else:
            raise StopIteration()
	\end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Iterators}
  \begin{block}{}
		If both iteratable and iterator are the same object, it is consumed in a single iteration.
	\end{block}
  \begin{minted}[fontsize=\scriptsize,bgcolor=Black]{python}
yr = yrange(1)
yr.next()
yr.next() # StopIteration
yr.next() # StopIteration
	\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Generators}
  \begin{itemize}
    \item Introduced with PEP 255, \textcolor{Orange}{generator functions} are a special kind of function that return a \textcolor{LimeGreen}{lazy iterator}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reading Large Files}
  \begin{block}{}
    A common use case of generators is to work with data streams or large files, like CSV files.
    These text files separate data into columns by using commas. This format is a common way to share data.
  \end{block}
  \begin{minted}[bgcolor=Black]{python}
csv_gen = csv_reader("some_csv.txt")
row_count = 0

for row in csv_gen:
  row_count += 1

print(f"Row count is {row_count}")
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reading Large Files (Cont'd)}
  \begin{block}{}
  This function opens a given file and uses \mintinline{python}|file.read()| along with \mintinline{python}|.split()|
  to add each line as a separate element to a list.
  \end{block}
  \begin{minted}[bgcolor=Black]{python}
def csv_reader(file_name):
  file = open(file_name)
  result = file.read().split("\n")
  return result
  \end{minted}
  \begin{block}{Memory Error}
    In this case, \mintinline{python}|open()| returns a generator object that you can lazily iterate through line by line.
    However, \mintinline{python}|file.read().split()| loads everything into memory at once, causing the \mintinline{python}|MemoryError|.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reading Large Files (Cont'd)}
  \begin{block}{}
    This version opens a file, loops through each line, and \textcolor{LimeGreen}{yields} each row, instead of returning it.
  \end{block}
  \begin{minted}[bgcolor=Black]{python}
def csv_reader(file_name):
  for row in open(file_name, "r"):
    yield row
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reading Large Files (Cont'd)}
  \begin{block}{Generator Comprehension}
  You can also define a generator expression (also called a generator comprehension), which has a very similar syntax to list comprehensions. In this way, you can use the generator without calling a function
  \end{block}
  \begin{minted}[bgcolor=Black]{python}
csv_gen = (row for row in open(file_name))
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating an Infinite Sequence}
  \begin{block}{}
    Generating an infinite sequence, will require the use of a generator, since your computer memory is finite.
  \end{block}
  \begin{minted}[bgcolor=Black]{python}
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1
  \end{minted}
\end{frame}

\end{document}
